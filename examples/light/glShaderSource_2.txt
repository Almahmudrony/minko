#version 100
#define NORMAL_MAP
#define NUM_SPOT_LIGHTS 1
#define DIFFUSE_MAP
#define NUM_AMBIENT_LIGHTS 1
#define MODEL_TO_WORLD
#define NUM_DIRECTIONAL_LIGHTS 2
#define NUM_POINT_LIGHTS 1
#define SHININESS
#define FRAGMENT_SHADER
struct AmbientLight
{
	vec3 color;
	float ambient;	
};

struct DirectionalLight
{
	vec3 color;
	float diffuse;
	float specular;
	vec3 direction;	
};

struct PointLight
{
	vec3 color;
	float diffuse;
	float specular;
	vec2 attenuationDistance;
	vec3 position;
};

struct SpotLight
{
	vec3 color;
	float diffuse;
	float specular;
	float attenuationDistance;
	vec3 position;
	vec3 direction;
	float cosInnerConeAngle;
	float cosOuterConeAngle;
};
float phong_diffuseReflection(vec3 normal, vec3 lightDirection)
{
	return max(dot(normal, lightDirection), 0.);
}

float phong_specularReflection(vec3 normal, vec3 lightDirection, vec3 viewVector, float shininess)
{
	float NdotL = dot(normal, lightDirection);
	
	if (NdotL < 0.0)
	{
		return 0.0;
	}
	else
	{
		vec3 reflected = 2.0 * NdotL * normal - lightDirection;

		return pow(max(dot(reflected, viewVector), 0.0), shininess);
	}
}

// compute the world space to tangent space matrix using the model's normal and tangent
// @precondition worldNormal is expected to be normalized.
mat3 getWorldToTangentSpaceMatrix(vec3 worldNormal, vec3 worldTangent)
{
	worldTangent = normalize(worldTangent);

	mat3 matrix = mat3(
		worldTangent,	
		cross(worldNormal, worldTangent),	
		worldNormal
	);

	mat3 transpose = mat3(
		matrix[0][0], matrix[1][0], matrix[2][0],
		matrix[0][1], matrix[1][1], matrix[2][1],
		matrix[0][2], matrix[1][2], matrix[2][2]
	);

	return transpose;
}

#ifdef FRAGMENT_SHADER

#ifdef GL_ES
	precision mediump float;
#endif

#ifdef NUM_AMBIENT_LIGHTS
	uniform AmbientLight ambientLights[NUM_AMBIENT_LIGHTS];
#endif // NUM_AMBIENT_LIGHTS

#ifdef PRECOMPUTED_AMBIENT
	uniform vec3 sumAmbients;
#endif // PRECOMPUTED_AMBIENT

#ifdef NUM_DIRECTIONAL_LIGHTS
	uniform DirectionalLight directionalLights[NUM_DIRECTIONAL_LIGHTS];
#endif // NUM_DIRECTIONAL_LIGHTS

#ifdef NUM_POINT_LIGHTS
	uniform PointLight pointLights[NUM_POINT_LIGHTS];
#endif // NUM_POINT_LIGHTS

#ifdef NUM_SPOT_LIGHTS
	uniform SpotLight spotLights[NUM_SPOT_LIGHTS];
#endif // NUM_SPOT_LIGHTS

uniform vec4 diffuseColor;
uniform sampler2D diffuseMap;
uniform sampler2D normalMap;
uniform sampler2D specularMap;
uniform sampler2D alphaMap;

uniform float shininess;
uniform float alphaThreshold;
uniform vec3 cameraPosition;

varying vec3 vertexPosition;
varying vec2 vertexUV;
varying vec3 vertexNormal;
varying vec3 vertexTangent;

void main(void)
{
	vec4 diffuse = diffuseColor;
	
	#ifdef DIFFUSE_MAP
		diffuse = texture2D(diffuseMap, vertexUV);
	#endif // DIFFUSE_MAP

	#ifdef ALPHA_MAP
		diffuse.a = texture2D(alphaMap, vertexUV).r;
	#endif // ALPHA_MAP

	#ifdef ALPHA_THRESHOLD
		if (diffuse.a < alphaThreshold)
			discard;
	#endif // ALPHA_THRESHOLD
	
	float specularIntensity = 1.0;
	
	#ifdef SPECULAR_MAP
		specularIntensity = texture2D(specularMap, vertexUV).r;
	#elif defined NORMAL_MAP
		specularIntensity = texture2D(normalMap, vertexUV).a;
	#endif // SPECULAR_MAP
	
	vec3 phong = vec3(0.);
	
	#ifdef PRECOMPUTED_AMBIENT
	//------------------------
		phong += sumAmbients;
	#else
	
		#ifdef NUM_AMBIENT_LIGHTS
			for (int i = 0; i < NUM_AMBIENT_LIGHTS; ++i)
			{
				phong += ambientLights[i].color * ambientLights[i].ambient;
			}
		#endif // NUM_AMBIENT_LIGHTS

	#endif // PRECOMPUTED_AMBIENT
	
	
	#if defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS || defined NUM_SPOT_LIGHTS
		
		vec3 lightDirection	= vec3(0.0);
		float contribution	= 0.0;
		
		vec3 normal		= normalize(vertexNormal);
		vec3 eyeVector	= cameraPosition - vertexPosition;

		#ifdef NORMAL_MAP
			// warning: the normal vector must be normalized at this point!
			mat3 worldToTangentMatrix = getWorldToTangentSpaceMatrix(normal, vertexTangent);
			
			normal		= normalize(2.0*texture2D(normalMap, vertexUV).xyz - 1.0);
			eyeVector	= worldToTangentMatrix * eyeVector;
		#endif // NORMAL_MAP
		
		eyeVector	= normalize(eyeVector);
		
		#ifdef NUM_DIRECTIONAL_LIGHTS
		//---------------------------
		for (int i = 0; i < NUM_DIRECTIONAL_LIGHTS; ++i)
		{
			lightDirection	= normalize(-directionalLights[i].direction);
			#ifdef NORMAL_MAP
				lightDirection = worldToTangentMatrix * lightDirection;
			#endif // NORMAL_MAP
			
			contribution	= phong_diffuseReflection(normal, lightDirection)
				* directionalLights[i].diffuse;

			#ifdef SHININESS
				contribution += phong_specularReflection(
					normal,
					lightDirection,
					eyeVector,
					shininess
				) * directionalLights[i].specular * specularIntensity;
			#endif // SHININESS

			phong += contribution * directionalLights[i].color;
		}
		#endif // NUM_DIRECTIONAL_LIGHTS
		
		#if