// phong effect
{
	"name"	: "phong",
	
	"attributeBindings"	: {
		"position"					: "geometry.vertex.attribute.position",
		"uv"						: "geometry.vertex.attribute.uv",
		"normal"					: "geometry.vertex.attribute.normal",
		"tangent"					: "geometry.vertex.attribute.tangent"
	},
	
	"uniformBindings"	: {
		"diffuseColor"				: "material.diffuseColor",
		"diffuseMap"				: "material.diffuseMap",
		"normalMap"					: "material.normalMap",
		"shininess"					: "material.shininess",
		"modelToWorldMatrix"		: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"		: "camera.worldToScreenMatrix",
		"cameraPosition"			: "camera.position"
	},
	
	"stateBindings"	: {
		"blendMode"					: "material.blendMode"
	},

	"macroBindings"	: {
		"DIFFUSE_MAP"				: "material.diffuseMap",
		"NORMAL_MAP"				: "material.normalMap",
		"SHININESS"					: "material.shininess",
		"MODEL_TO_WORLD"			: "transform.modelToWorldMatrix",
		"NUM_AMBIENT_LIGHTS"		: "ambientLights.length",
		"PRECOMPUTED_AMBIENT"		: "sumAmbients",
		"NUM_DIRECTIONAL_LIGHTS"	: "directionalLights.length",
		"NUM_POINT_LIGHTS"			: "pointLights.length",
		"NUM_SPOT_LIGHTS"			: "spotLights.length"
	},
	
	"priority"			: 0,
	"blendMode"			: ["one", "zero"],
	"depthTest"			: [true, "less_equal"],
	"triangleCulling"	: "back",
	
	"samplerStates" : {
		"diffuseMap"	: { "filter" : "linear", "mipFilter" : "linear" }
	},

	"includes"	: [ "Phong.glsl", "NormalMap.glsl", "LightTypes.glsl" ],
	
	"passes"	: [{	
		"vertexShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif
		
			attribute vec3 position;
			attribute vec2 uv;
			attribute vec3 normal;
			attribute vec3 tangent;

			uniform mat4 modelToWorldMatrix;
			uniform mat4 worldToScreenMatrix;

			varying vec3 vertexPosition;
			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 vertexTangent;

			void main(void)
			{
				#ifdef DIFFUSE_MAP
					vertexUV = uv;
				#endif

				vec4 worldPosition = vec4(position, 1.0);
				#ifdef MODEL_TO_WORLD
					worldPosition = modelToWorldMatrix * worldPosition;
				#endif // MODEL_TO_WORLD
				
				#if defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS || defined NUM_SPOT_LIGHTS
				
					vertexPosition	= worldPosition.xyz;
					
					vertexNormal = normal;				
					#ifdef MODEL_TO_WORLD
						vertexNormal = mat3(modelToWorldMatrix) * vertexNormal;
					#endif // MODEL_TO_WORLD
					vertexNormal = normalize(vertexNormal);
					
					#ifdef NORMAL_MAP
						vertexTangent = tangent;
						#ifdef MODEL_TO_WORLD
							vertexTangent = mat3(modelToWorldMatrix) * vertexTangent;
						#endif // MODEL_TO_WORLD
						vertexTangent = normalize(vertexTangent);
					#endif // NORMAL_MAP
					
				#endif // defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS || defined NUM_SPOT_LIGHTS

				gl_Position =  worldToScreenMatrix * worldPosition;
			}
		",
		"fragmentShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif

			#ifdef NUM_AMBIENT_LIGHTS
				uniform AmbientLight ambientLights[NUM_AMBIENT_LIGHTS];
			#endif // NUM_AMBIENT_LIGHTS
			
			#ifdef PRECOMPUTED_AMBIENT
				uniform vec3 sumAmbients;
			#endif // PRECOMPUTED_AMBIENT
			
			#ifdef NUM_DIRECTIONAL_LIGHTS
				uniform DirectionalLight directionalLights[NUM_DIRECTIONAL_LIGHTS];
			#endif // NUM_DIRECTIONAL_LIGHTS
			
			#ifdef NUM_POINT_LIGHTS
				uniform PointLight pointLights[NUM_POINT_LIGHTS];
			#endif // NUM_POINT_LIGHTS
			
			#ifdef NUM_SPOT_LIGHTS
				uniform SpotLight spotLights[NUM_SPOT_LIGHTS];
			#endif // NUM_SPOT_LIGHTS
			
			uniform vec4 diffuseColor;
			uniform sampler2D diffuseMap;
			uniform sampler2D normalMap;
			
			uniform float shininess;
			uniform vec3 cameraPosition;
			
			varying vec3 vertexPosition;
			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 vertexTangent;

			void main(void)
			{
				vec4 diffuse = vec4(0);
				
				#ifdef DIFFUSE_MAP
					diffuse = texture2D(diffuseMap, vertexUV);
				#else
					diffuse = diffuseColor;
				#endif // DIFFUSE_MAP
				
				
				vec3 phong = vec3(0.);
				
				#ifdef PRECOMPUTED_AMBIENT
				//------------------------
					phong += sumAmbients;
				#else
				
					#ifdef NUM_AMBIENT_LIGHTS
						for (int i = 0; i < NUM_AMBIENT_LIGHTS; ++i)
						{
							phong += ambientLights[i].color * ambientLights[i].ambient;
						}
					#endif // NUM_AMBIENT_LIGHTS
		
				#endif // PRECOMPUTED_AMBIENT
				
				
				#if defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS || defined NUM_SPOT_LIGHTS
					
					vec3 lightDirection	= vec3(0.0);
					float contribution	= 0.0;
					
					vec3 normal		= normalize(vertexNormal);
					vec3 eyeVector	= cameraPosition - vertexPosition;

					#ifdef NORMAL_MAP
						// warning: the normal vector must be normalized at this point!
						mat3 worldToTangentMatrix = getWorldToTangentSpaceMatrix(normal, vertexTangent);
						
						normal		= normalize(2.0*texture2D(normalMap, vertexUV).xyz - 1.0);
						eyeVector	= worldToTangentMatrix * eyeVector;
					#endif // NORMAL_MAP
					
					eyeVector	= normalize(eyeVector);
					
					#ifdef NUM_DIRECTIONAL_LIGHTS
					//---------------------------
					for (int i = 0; i < NUM_DIRECTIONAL_LIGHTS; ++i)
					{
						lightDirection	= normalize(-directionalLights[i].direction);
						#ifdef NORMAL_MAP
							lightDirection = worldToTangentMatrix * lightDirection;
						#endif // NORMAL_MAP
						
						contribution	= phong_diffuseReflection(normal, lightDirection)
							* directionalLights[i].diffuse;

						#ifdef SHININESS
							contribution += phong_specularReflection(
								normal,
								lightDirection,
								eyeVector,
								shininess
							) * directionalLights[i].specular;
						#endif // SHININESS

						phong += contribution * directionalLights[i].color;
					}
					#endif // NUM_DIRECTIONAL_LIGHTS
					
					#ifdef NUM_POINT_LIGHTS
					//---------------------
					for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
					{
						lightDirection	= normalize(pointLights[i].position - vertexPosition);
						#ifdef NORMAL_MAP
							lightDirection = worldToTangentMatrix * lightDirection;
						#endif // NORMAL_MAP
						
						contribution	= phong_diffuseReflection(normal, lightDirection)
							* pointLights[i].diffuse;

						#ifdef SHININESS
							contribution += phong_specularReflection(
								normal,
								lightDirection,
								eyeVector,
								shininess
							) * pointLights[i].specular;
						#endif // SHININESS

						phong += contribution * pointLights[i].color;
					}
					#endif // NUM_POINT_LIGHTS
					
					#ifdef NUM_SPOT_LIGHTS
					//--------------------
					for (int i = 0; i < NUM_SPOT_LIGHTS; ++i)
					{
						lightDirection		= normalize(spotLights[i].position - vertexPosition);
						vec3  spotDirection	= normalize(-spotLights[i].direction);						
						float cosSpot		= dot(-lightDirection, spotDirection);
						float cosOuter		= spotLights[i].cosOuterConeAngle;

						if (cosOuter < cosSpot)
						{
							#ifdef NORMAL_MAP
								lightDirection	= worldToTangentMatrix * lightDirection;
								spotDirection	= worldToTangentMatrix * spotDirection;
							#endif // NORMAL_MAP
						
							contribution	= phong_diffuseReflection(normal, lightDirection)
								* spotLights[i].diffuse;

							#ifdef SHININESS
								contribution += phong_specularReflection(
									normal,
									lightDirection,
									eyeVector,
									shininess
								) * spotLights[i].specular;
							#endif // SHININESS
							
							float cosInner	= spotLights[i].cosInnerConeAngle;
							float cutoff	= cosSpot < cosInner && cosOuter < cosInner 
											? (cosSpot - cosOuter) / (cosInner - cosOuter) 
											: 1.0;
							contribution	*= cutoff;
							
							phong += contribution * spotLights[i].color;
						}
					}
					#endif // NUM_SPOT_LIGHTS
					
				#endif // defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS || defined NUM_SPOT_LIGHTS
				
				diffuse = vec4(diffuse.rgb * phong, diffuse.a);
				
				gl_FragColor = diffuse;
			}
		"
	}]
}
