// phong effect
{
	"name"	: "phong",
	
	"attributeBindings"	: {
		"position"					: "geometry.vertex.attribute.position",
		"uv"						: "geometry.vertex.attribute.uv",
		"normal"					: "geometry.vertex.attribute.normal"
	},
	
	"uniformBindings"	: {
		"diffuseColor"				: "material.diffuseColor",
		"diffuseMap"				: "material.diffuseMap",
		"shininess"					: "material.shininess",
		"modelToWorldMatrix"		: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"		: "camera.worldToScreenMatrix",
		"cameraPosition"			: "camera.position"
	},
	
	"stateBindings"	: {
		"blendMode"					: "material.blendMode"
	},

	"macroBindings"	: {
		"DIFFUSE_MAP"				: "material.diffuseMap",
		"SHININESS"					: "material.shininess",
		"MODEL_TO_WORLD"			: "transform.modelToWorldMatrix",
		"NUM_AMBIENT_LIGHTS"		: "ambientLights.length",
		"PRECOMPUTED_AMBIENT"		: "sumAmbients",
		"NUM_DIRECTIONAL_LIGHTS"	: "directionalLights.length",
		"NUM_POINT_LIGHTS"			: "pointLights.length"
	},
	
	"priority"			: 0,
	"blendMode"			: ["one", "zero"],
	"depthTest"			: [true, "less_equal"],
	"triangleCulling"	: "back",
	
	"samplerStates" : {
		"diffuseMap"	: { "filter" : "linear", "mipFilter" : "linear" }
	},

	"includes"	: [ "Phong.glsl", "LightTypes.glsl" ],
	
	"passes"	: [{	
		"vertexShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif
		
			attribute vec3 position;
			attribute vec2 uv;
			attribute vec3 normal;

			uniform mat4 modelToWorldMatrix;
			uniform mat4 worldToScreenMatrix;

			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 vertexPosition;

			void main(void)
			{
				#ifdef DIFFUSE_MAP
					vertexUV = uv;
				#endif

				vec4 worldPosition = vec4(position, 1.0);
				#ifdef MODEL_TO_WORLD
					worldPosition = modelToWorldMatrix * worldPosition;
				#endif // MODEL_TO_WORLD
				
				#if defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS
					vertexPosition	= worldPosition.xyz;
					
					vertexNormal	= normal;
					#ifdef MODEL_TO_WORLD
						vertexPosition	= 
						vertexNormal	= mat3(modelToWorldMatrix) * vertexNormal;
					#endif
					vertexNormal	= normalize(vertexNormal);
				#endif // defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS

				gl_Position =  worldToScreenMatrix * worldPosition;
			}
		",
		"fragmentShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif

			#ifdef NUM_AMBIENT_LIGHTS
				uniform AmbientLight ambientLights[NUM_AMBIENT_LIGHTS];
			#endif // NUM_AMBIENT_LIGHTS
			
			#ifdef PRECOMPUTED_AMBIENT
				uniform vec3 sumAmbients;
			#endif // PRECOMPUTED_AMBIENT
			
			#ifdef NUM_DIRECTIONAL_LIGHTS
				uniform DirectionalLight directionalLights[NUM_DIRECTIONAL_LIGHTS];
			#endif // NUM_DIRECTIONAL_LIGHTS
			
			#ifdef NUM_POINT_LIGHTS
				uniform PointLight pointLights[NUM_POINT_LIGHTS];
			#endif // NUM_POINT_LIGHTS
			
			#ifdef NUM_SPOT_LIGHTS
				uniform SpotLight spotLights[NUM_SPOT_LIGHTS];
			#endif // NUM_SPOT_LIGHTS
			
			uniform vec4 diffuseColor;
			uniform sampler2D diffuseMap;
			uniform float shininess;
			uniform vec3 cameraPosition;
			
			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 vertexPosition;

			void main(void)
			{
				vec4 diffuse = vec4(0);

				// diffuse
				#ifdef DIFFUSE_MAP
					diffuse = texture2D(diffuseMap, vertexUV);
				#else
					diffuse = diffuseColor;
				#endif

				vec3 phong = vec3(0.);
				#ifdef PRECOMPUTED_AMBIENT
					phong += sumAmbients;
				#else
				
					#ifdef NUM_AMBIENT_LIGHTS
						for (int i = 0; i < NUM_AMBIENT_LIGHTS; ++i)
						{
							phong += ambientLights[i].color * ambientLights[i].ambient;
						}
					#endif // NUM_AMBIENT_LIGHTS
		
				#endif // PRECOMPUTED_AMBIENT
				
				#if defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS
					vec3 eyeVector		= normalize(cameraPosition - vertexPosition);
					vec3 normal			= normalize(vertexNormal);
					
					vec3 lightDirection	= vec3(0.0);
					float contribution	= 0.0;
					
					#ifdef NUM_DIRECTIONAL_LIGHTS
					//---------------------------
					for (int i = 0; i < NUM_DIRECTIONAL_LIGHTS; ++i)
					{
						lightDirection	= normalize(-directionalLights[i].direction);
						contribution	= phong_diffuseReflection(normal, lightDirection)
							* directionalLights[i].diffuse;

						#ifdef SHININESS
							contribution += phong_specularReflection(
								normal,
								lightDirection,
								eyeVector,
								shininess
							) * directionalLights[i].specular;
						#endif // SHININESS

						phong += contribution * directionalLights[i].color;
					}
					#endif // NUM_DIRECTIONAL_LIGHTS
					
					#ifdef NUM_POINT_LIGHTS
					//---------------------
					for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
					{
						lightDirection	= normalize(pointLights[i].position - vertexPosition);
						contribution	= phong_diffuseReflection(normal, lightDirection)
							* pointLights[i].diffuse;

						#ifdef SHININESS
							contribution += phong_specularReflection(
								normal,
								lightDirection,
								eyeVector,
								shininess
							) * pointLights[i].specular;
						#endif // SHININESS

						phong += contribution * pointLights[i].color;
					}
					#endif // NUM_POINT_LIGHTS
					
					diffuse = vec4(diffuse.rgb * phong, diffuse.a);
				#endif // defined NUM_DIRECTIONAL_LIGHTS || defined NUM_POINT_LIGHTS

				//#ifdef AMBIENTS_CONTRIBUTION
				//gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
				//#else
				//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				//#endif // AMBIENTS_CONTRIBUTION
				gl_FragColor = vec4(phong, 1.0);
				//gl_FragColor = diffuse;
			}
		"
	}]
}
