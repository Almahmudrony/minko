// phong effect
{
	"name"	: "phong",
	
	"attributeBindings"	: {
		"position"				: "geometry.vertex.attribute.position",
		"uv"					: "geometry.vertex.attribute.uv",
		"normal"				: "geometry.vertex.attribute.normal"
	},
	
	"uniformBindings"	: {
		"diffuseColor"			: "material.diffuseColor",
		"diffuseMap"			: "material.diffuseMap",
		"shininess"				: "material.shininess",
		"modelToWorldMatrix"	: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"	: "camera.worldToScreenMatrix",
		"cameraPosition"		: "camera.position"
	},
	
	"stateBindings"	: {
		"blendMode"				: "material.blendMode"
	},

	"macroBindings"	: {
		"DIFFUSE_MAP"			: "material.diffuseMap",
		"SHININESS"				: "material.shininess",
		"MODEL_TO_WORLD"		: "transform.modelToWorldMatrix",
		"DIRECTIONAL_LIGHTS"	: "directionalLights[0].color"
	},
	
	"priority"			: 0,
	"blendMode"			: ["one", "zero"],
	"depthTest"			: [true, "less_equal"],
	"triangleCulling"	: "back",
	
	"samplerStates" : {
		"diffuseMap"	: { "filter" : "linear", "mipFilter" : "linear" }
	},

	"includes"	: [ "Phong.glsl" ],
	
	"passes"	: [{	
		"vertexShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif
		
			attribute vec3 position;
			attribute vec2 uv;
			attribute vec3 normal;

			uniform mat4 modelToWorldMatrix;
			uniform mat4 worldToScreenMatrix;
			uniform vec3 cameraPosition;

			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 eyeVector;

			void main(void)
			{
				#ifdef DIFFUSE_MAP
					vertexUV = uv;
				#endif

				vec4 pos = vec4(position, 1.0);
				
				#ifdef MODEL_TO_WORLD
					pos = modelToWorldMatrix * pos;
				#endif
				
				#ifdef DIRECTIONAL_LIGHTS
					vec3 worldNormal = normal;
					#ifdef MODEL_TO_WORLD
						worldNormal = mat3(modelToWorldMatrix) * worldNormal;
					#endif
					vertexNormal = normalize(worldNormal);

					eyeVector = normalize(cameraPosition.xyz - pos.xyz);
				#endif

				gl_Position =  worldToScreenMatrix * pos;
			}
		",
		"fragmentShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif

			uniform DirectionalLight 	directionalLights[1];
			uniform vec4 				diffuseColor;
			uniform sampler2D 			diffuseMap;
			uniform float				shininess;
			
			varying vec2 vertexUV;
			varying vec3 vertexNormal;
			varying vec3 eyeVector;

			void main(void)
			{
				vec4 diffuse = vec4(0);

				#ifdef DIFFUSE_MAP
					diffuse = texture2D(diffuseMap, vertexUV);
				#else
					diffuse = diffuseColor;
				#endif

				#ifdef DIRECTIONAL_LIGHTS
					vec3 normal = normalize(vertexNormal);
					vec3 lightDirection = normalize(-directionalLights[0].direction);
					float phong = phong_diffuseReflection(vertexNormal, lightDirection)
						* directionalLights[0].diffuse;

					#ifdef SHININESS
						phong += phong_specularReflection(
							vertexNormal,
							lightDirection,
							normalize(eyeVector),
							shininess
						) * directionalLights[0].specular;
					#endif

					diffuse = vec4(diffuse.rgb * (phong * directionalLights[0].color), diffuse.a);
				#endif

				gl_FragColor = diffuse;
			}
		"
	}]
}
