// sponza lighting effect
{
	"name"				: "sponza lighting",
	"attributeBindings"	: {
		"position"				: "geometry.vertex.attribute.position",
		"normal"				: "geometry.vertex.attribute.normal",
		"uv"					: "geometry.vertex.attribute.uv",
		"tangent"				: "geometry.vertex.attribute.tangent"
	},
	"uniformBindings"	: {
		"modelToWorldMatrix"	: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"	: "camera.worldToScreenMatrix",
		"lightDirection"		: "light.direction",
		"ambientColor"			: "light.ambient.rgba",
		"lightColor"			: "light.diffuse.rgba",
		"cameraPosition"		: "camera.position",
		"diffuseMap"			: "material.diffuseMap",
		"specularMap"			: "material.specularMap",
		"normalMap"				: "material.normalMap",
		"alphaMap"				: "material.alphaMap",
		"shininess"				: "material.shininess",
		"alphaThreshold"		: "material.alphaThreshold"
	},
	"stateBindings"	: {
		"blendMode"				: "material.blendMode",
		"triangleCulling"		: "material.triangleCulling"
	},
	"macroBindings"	: {
		"MODEL_TO_WORLD"		: "transform.modelToWorldMatrix",
		"DIFFUSE_MAP"			: "material.diffuseMap",
		"SPECULAR"				: "material.shininess",
		"SPECULAR_MAP"			: "material.specularMap",
		"NORMAL_MAP"			: "material.normalMap",
		"ALPHA_MAP"				: "material.alphaMap",
		"ALPHA_THRESHOLD"		: "material.alphaThreshold"
	},

	"priority"			: 0,
	"blendMode"			: "alpha",
	"depthTest"			: [ true, "less" ],
	"triangleCulling"	: "none",
	
	"samplerStates"	: {
		"material.alphaMap"		: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "none" },
		"material.diffuseMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "linear" },
		"material.specularMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "linear" },
		"material.normalMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "linear" }
	},

	"passes"		: [{
		"vertexShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif

			attribute vec3	position;
			
			attribute vec3	normal;
			attribute vec2	uv;
			attribute vec3	tangent;
			
			varying vec3	worldPosition;
			varying vec3	worldNormal;
			varying vec3	worldTangent;
			
			varying vec2	vertexUV;
			varying vec3	eyeVec;

			uniform mat4	modelToWorldMatrix;
			uniform mat4	worldToScreenMatrix;
			
			void main(void)
			{
				vec4 pos = vec4(position, 1.0);

				worldNormal	= normal;

				#ifdef MODEL_TO_WORLD
					pos			= modelToWorldMatrix * pos;
					worldNormal	= mat3(modelToWorldMatrix) * worldNormal;
				#endif

				worldNormal = normalize(worldNormal);
				
				#ifdef SPECULAR
					worldPosition = pos.xyz;
				#endif

				#if defined DIFFUSE_MAP || defined NORMAL_MAP || defined SPECULAR_MAP 
					vertexUV = uv;
				#endif
				
				#ifdef NORMAL_MAP
					worldTangent = tangent;
					#ifdef MODEL_TO_WORLD
						worldTangent = mat3(modelToWorldMatrix) * tangent;
					#endif
				#endif
				
				gl_Position =  worldToScreenMatrix * pos;
			}
		",
		"fragmentShader"	: "
			#ifdef GL_ES
				precision mediump float;
			#endif

			struct Material {
				vec4		diffuseColor;
				vec3		specular;
				float		shininess;
				float		alphaThreshold;
			};
			uniform sampler2D	specularMap;
			uniform sampler2D	normalMap;
			uniform sampler2D	diffuseMap;
			uniform sampler2D	alphaMap;
	
			struct SponzaLighting{
				vec3 lightWorldPosition1;
				vec3 lightAmbient1;
				vec3 lightDiffuse1;
				vec3 lightSpecular1;
				vec3 lightWorldPosition2;
				vec3 lightAmbient2;
				vec3 lightDiffuse2;
				vec3 lightSpecular2;
				vec3 lightWorldPosition3;
				vec3 lightAmbient3;
				vec3 lightDiffuse3;
				vec3 lightSpecular3;
				vec3 lightWorldPosition4;
				vec3 lightAmbient4;
				vec3 lightDiffuse4;
				vec3 lightSpecular4;
				vec4 lightDistThres;
			};
			
			struct DirectionalLight {
				vec3 direction;
				vec3 diffuse;
				vec3 specular;
				vec3 ambient;
			};
			
			uniform	Material			material;
			uniform DirectionalLight	light;
			uniform SponzaLighting		sponza;
			uniform vec3				cameraPosition;
			uniform float				shininess;
			uniform float				alphaThreshold;

			varying vec3				worldPosition;
			varying vec3				worldNormal;
			varying vec3				worldTangent;
			varying vec2				vertexUV;

			float phong_lambert(vec3 normal,  vec3 lightDirection)
			{
				return max(dot(normal, lightDirection), 0.);
			}

			vec3 phong_diffuseReflection(vec3 normal,  vec3 lightDirection,  vec3 lightColor)
			{
				return lightColor * phong_lambert(normal, lightDirection);
			}

			vec3 phong_specularReflection(vec3 normal,  vec3 lightDirection,  vec3 viewVector,  vec3 specularColor,  float shininess)
			{
				float NdotL = dot(normal, lightDirection);
	
				if (NdotL < 0.0)
				{
					return vec3(0.0);
				}
				else
				{
					vec3 reflected = 2.0 * NdotL * normal - lightDirection;

					float specular = pow(max(dot(reflected, viewVector), 0.0), max(shininess, 0.00000001));

					return specular * specularColor;
				}
			}
			
			// compute the world space to tangent space matrix using the model's normal and tangent
			mat3 getWorldToTangentSpaceMatrix(vec3 wsNormal, vec3 wsTangent)
			{
				// both vectors are assumed to be normalized.
				wsTangent	= normalize(wsTangent);

				mat3 a = mat3(
					wsTangent,	
					cross(wsNormal, wsTangent),	
					wsNormal
				);

				mat3 transpose = mat3(a[0][0], a[1][0], a[2][0],
						      a[0][1], a[1][1], a[2][1],
						      a[0][2], a[1][2], a[2][2]);

				return transpose;
			}	
			
			void main(void)
			{
				#ifdef DIFFUSE_MAP
					vec4 diffuse = texture2D(diffuseMap, vertexUV);
				#else
					vec4 diffuse = material.diffuseColor;
				#endif

				vec3 worldNormal 		= normalize(worldNormal);
				#ifdef NORMAL_MAP
					vec3 nWorldTangent			= normalize(worldTangent);
					mat3 worldToTangentMatrix 	= getWorldToTangentSpaceMatrix(worldNormal, nWorldTangent);
				#endif // NORMAL_MAP
				
				vec3 worldEyeVector		= normalize(cameraPosition - worldPosition);
				
				vec4 distanceLights		= vec4(1.0);
				
				vec3 worldLightVector1	= sponza.lightWorldPosition1 - worldPosition;
				distanceLights.x		= length(worldLightVector1);
				worldLightVector1		= worldLightVector1.xyz / distanceLights.x;
								
				vec3 worldLightVector2	= sponza.lightWorldPosition2 - worldPosition;
				distanceLights.y		= length(worldLightVector2);
				worldLightVector2		= worldLightVector2.xyz / distanceLights.y;
				
				vec3 worldLightVector3	= sponza.lightWorldPosition3 - worldPosition;
				distanceLights.z		= length(worldLightVector3);
				worldLightVector3		= worldLightVector3.xyz / distanceLights.z;
				
				vec3 worldLightVector4	= sponza.lightWorldPosition4 - worldPosition;
				distanceLights.w		= length(worldLightVector4);
				worldLightVector4		= worldLightVector4.xyz / distanceLights.w;
				
				vec4 attenuations		= max(1.0 - distanceLights / sponza.lightDistThres, 0.0);
				
				// by default, everything is in world space
				vec3 normal			= worldNormal;
				vec3 eyeVector		= worldEyeVector;
				vec3 lightVector1	= worldLightVector1;
				vec3 lightVector2	= worldLightVector2;
				vec3 lightVector3	= worldLightVector3;
				vec3 lightVector4	= worldLightVector4;
				
				// map all world-space vectors to tangent-space if possible
				#ifdef NORMAL_MAP
					normal			= normalize(2.0 * texture2D(normalMap, vertexUV).xyz - 1.0);
					eyeVector		= normalize(worldToTangentMatrix * worldEyeVector);
					lightVector1	= normalize(worldToTangentMatrix * worldLightVector1);
					lightVector2	= normalize(worldToTangentMatrix * worldLightVector2);
					lightVector3	= normalize(worldToTangentMatrix * worldLightVector3);
					lightVector4	= normalize(worldToTangentMatrix * worldLightVector4);
				#endif // NORMAL_MAP
				
				
				// ambient 
				vec3 lightsAmbient = sponza.lightAmbient1;
				
				// diffuse lighting
				vec3 lightsDiffuse 	= phong_diffuseReflection(normal, lightVector1, sponza.lightDiffuse1) * attenuations.x;
				lightsDiffuse 		+= phong_diffuseReflection(normal, lightVector2, sponza.lightDiffuse2) * attenuations.y;
				lightsDiffuse 		+= phong_diffuseReflection(normal, lightVector3, sponza.lightDiffuse3) * attenuations.z;
				lightsDiffuse 		+= phong_diffuseReflection(normal, lightVector4, sponza.lightDiffuse4) * attenuations.w;
				
				
				// specular lighting
				vec3 lightsSpecular = vec3(0.0);
				#if defined(SPECULAR) || defined(SPECULAR_MAP)
					#ifdef SPECULAR_MAP
						vec3 specular	= texture2D(specularMap, vertexUV).rgb;
					#else // SPECULAR_MAP
						vec3 specular	= material.specular;
					#endif // SPECULAR_MAP
				
					lightsSpecular += phong_specularReflection(normal, lightVector1, eyeVector, specular * sponza.lightSpecular1, shininess) * attenuations.x;
					lightsSpecular += phong_specularReflection(normal, lightVector2, eyeVector, specular * sponza.lightSpecular2, shininess) * attenuations.y;
					lightsSpecular += phong_specularReflection(normal, lightVector3, eyeVector, specular * sponza.lightSpecular3, shininess) * attenuations.z;
					lightsSpecular += phong_specularReflection(normal, lightVector4, eyeVector, specular * sponza.lightSpecular4, shininess) * attenuations.w;
				#endif // SPECULAR || SPECULAR_MAP
				
				#ifdef ALPHA_MAP
					vec4 alphaMapColor = texture2D(alphaMap, vertexUV);

					float alpha = alphaMapColor.x;
				#else
					float alpha = 1.;
				#endif

				
				gl_FragColor = clamp(
					vec4((lightsAmbient + lightsDiffuse)*diffuse.xyz + lightsSpecular, alpha),
					0.0,
					1.0
				);
				
				#ifdef ALPHA_THRESHOLD
					if (gl_FragColor.a < alphaThreshold)
						discard;
				#endif
			}
		"
	}]
}
