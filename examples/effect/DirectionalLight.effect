// directional light effect
{
	"name"				: "directional light",
	"attributeBindings"	: {
		"position"					: "geometry.vertex.attribute.position",
		"normal"					: "geometry.vertex.attribute.normal",
		"uv"						: "geometry.vertex.attribute.uv"
	},
	"uniformBindings"	: {
		"diffuseColor"				: "material.diffuse.rgba",
		"diffuseMap"				: "material.diffuse.map",
		"modelToWorldMatrix"		: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"		: "transform.worldToScreenMatrix",
		"lightDirection"			: "light.direction",
		"ambientColor"				: "light.ambient.rgba"
	},
	"stateBindings"	: {
		"blendMode"					: "material.blendMode"
	},
	"macroBindings"	: {
		"TECHNIQUE_DIFFUSE_MAP"		: "material.diffuse.map",
		"TECHNIQUE_PHONG_SPECULAR"	: "material.phong.exponent"
	},

	"priority"			: 0,
	"blendMode"			: ["one", "zero"],
	"depthTest"			: { "depthMask" : true, "depthFunc" : "less" },
	"triangleCulling"	: "back",
	
	"samplerStates"	: {
		"diffuseMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "none" }
	},

	"includes"		: [ "Phong.glsl" ],

	"passes"		: [{
		"vertexShader"	: "
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec3 uv;

			varying vec3 worldNormal;
			varying vec2 vertexUV;
			varying vec3 eyeVec;

			uniform mat4 modelToWorldMatrix;
			uniform mat4 worldToScreenMatrix;

			void main(void)
			{
				#ifdef TECHNIQUE_DIFFUSE_MAP
					vertexUV = uv;
				#endif

				worldNormal = normalize(mat3(modelToWorldMatrix) * normal);
				
				gl_Position =  worldToScreenMatrix * modelToWorldMatrix * vec4(position, 1.0);
			}
		",
		"fragmentShader"	: "
			// diffuse properties
			uniform vec4 diffuseColor;
			uniform sampler2D diffuseMap;

			// light properties
			uniform vec3 ambientColor;
			uniform vec3 lightDirection;

			varying vec3 worldNormal;
			varying vec2 vertexUV;

			void main(void)
			{
				#ifdef TECHNIQUE_DIFFUSE_MAP
					vec4 diffuse = texture2D(diffuseMap, vertexUV);
				#else
					vec4 diffuse = diffuseColor;
				#endif;

				float lambert = phong_lambert(worldNormal, normalize(-lightDirection));
				vec3 light = ambientColor + lambert;

				#ifdef TECHNIQUE_PHONG_SPECULAR
					// FIXME: do specular lighting here
				#endif

				gl_FragColor = vec4(diffuse * light.rgb, diffuse.a);
			}
		"
	}]
}
