// directional light effect
{
	"name"				: "directional light",
	"attributeBindings"	: {
		"position"				: "geometry/vertex/attribute/position",
		"normal"				: "geometry/vertex/attribute/normal",
		"uv"					: "geometry/vertex/attribute/uv"
	},
	"uniformBindings"	: {
		"diffuseColor"			: "material/diffuse/rgba",
		"diffuseMap"			: "material/diffuse/map",
		"modelToWorldMatrix"	: "transform/modelToWorldMatrix",
		"worldToScreenMatrix"	: "transform/worldToScreenMatrix",
		"lightDirection"		: "light/direction",
		"ambientColor"			: "light/ambient/rgba"
	},
	"stateBindings"	: {
		"blendMode"				: "material/blendMode"
	},
	"macroBindings"	: {
		"TECHNIQUE_DIFFUSE_MAP"	: "material/diffuse/map"
	},

	"priority"		: 0,
	"blendMode"		: ["one", "zero"],
	"depthTest"		: [true, "less"],
	
	"includes"		: [ "Phong.glsl" ],
	
	"passes"		: [{
		"vertexShader"	: "
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec3 uv;

			varying vec3 worldNormal;
			varying vec2 vertexUV;

			uniform mat4 modelToWorldMatrix;
			uniform mat4 worldToScreenMatrix;

			void main(void)
			{
				#ifdef TECHNIQUE_DIFFUSE_MAP
					vertexUV = uv;
				#endif

				worldNormal = normalize(mat3(modelToWorldMatrix) * normal);

				gl_Position =  worldToScreenMatrix * modelToWorldMatrix * vec4(position, 1.0);
			}
		",
		"fragmentShader"	: "
			uniform vec4 diffuseColor;
			uniform vec3 ambientColor;
			uniform vec3 lightDirection;
			uniform sampler2D diffuseMap;

			varying vec3 worldNormal;
			varying vec2 vertexUV;

			void main(void)
			{
				#ifdef TECHNIQUE_DIFFUSE_MAP
					vec4 diffuse = texture2D(diffuseMap, vertexUV);
				#else
					vec4 diffuse = diffuseColor;
				#endif;

				vec3 light = ambientColor + lambert(worldNormal, lightDirection);

				gl_FragColor = vec4(diffuse * light.rgb, diffuse.a);
			}
		"
	}]
}
