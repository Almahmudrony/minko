// directional light effect
{
	"name"				: "directional light",
	"attributeBindings"	: {
		"position"				: "geometry.vertex.attribute.position",
		"normal"				: "geometry.vertex.attribute.normal",
		"uv"					: "geometry.vertex.attribute.uv",
		"tangent"				: "geometry.vertex.attribute.tangent"
	},
	"uniformBindings"	: {
		"modelToWorldMatrix"	: "transform.modelToWorldMatrix",
		"worldToScreenMatrix"	: "camera.worldToScreenMatrix",
		"lightDirection"		: "light.direction",
		"ambientColor"			: "light.ambient.rgba",
		"lightColor"			: "light.diffuse.rgba",
		"cameraPosition"		: "camera.position"
	},
	"stateBindings"	: {
		"blendMode"				: "material.blendMode"
	},
	"macroBindings"	: {
		"MODEL_TO_WORLD"		: "transform.modelToWorldMatrix",
		"DIFFUSE_MAP"			: "material.diffuseMap",
		"SPECULAR"				: "material.shininess",
		"SPECULAR_MAP"			: "material.specularMap",
		"NORMAL_MAP"			: "material.normalMap"
	},

	"priority"			: 0,
	"blendMode"			: ["one", "zero"],
	"depthTest"			: [ true, "less" ],
	"triangleCulling"	: "back",
	
	"samplerStates"	: {
		"material.diffuseMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "none" },
		"material.specularMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "none" },
		"material.normalMap"	: { "wrapMode" : "repeat", "textureFilter" : "linear", "mipFilter" : "none" }
	},

	"includes"		: [ "Phong.glsl" ],

	"passes"		: [{
		"vertexShader"	: "
			attribute vec3	position;
			
			attribute vec3	normal;
			attribute vec3	uv;
			attribute vec3	tangent;
			
			varying vec3	worldPosition;
			varying vec3	worldNormal;
			varying vec3	worldTangent;
			
			varying vec2	vertexUV;
			varying vec3	eyeVec;

			uniform mat4	modelToWorldMatrix;
			uniform mat4	worldToScreenMatrix;
			
			void main(void)
			{
				vec4 pos = vec4(position, 1.0);

				worldNormal	= normal;

				#ifdef MODEL_TO_WORLD
					pos			= modelToWorldMatrix * pos;
					worldNormal	= mat3(modelToWorldMatrix) * worldNormal;
				#endif

				worldNormal = normalize(worldNormal);
				
				#ifdef SPECULAR
					worldPosition = pos.xyz;
				#endif

				#ifdef DIFFUSE_MAP
					vertexUV = uv;
				#endif
				
				#ifdef NORMAL_MAP
					worldTangent = tangent;
					#ifdef MODEL_TO_WORLD
						worldTangent = mat3(modelToWorldMatrix) * tangent;
					#endif
				#endif
				
				gl_Position =  worldToScreenMatrix * pos;
			}
		",
		"fragmentShader"	: "

			struct Material {
				sampler2D	diffuseMap;
				vec4		diffuseColor;
				vec3		specular;
				float		shininess;
				sampler2D	specularMap;
				sampler2D	normalMap;
			};

			struct DirectionalLight {
				vec3 direction;
				vec3 diffuse;
				vec3 specular;
				vec3 ambient;
			};
			
			
			uniform	Material			material;
			uniform DirectionalLight	light;
			uniform vec3				cameraPosition;

			varying vec3		worldPosition;
			varying vec3		worldNormal;
			varying vec3		worldTangent;
			varying vec2		vertexUV;
			

			void main(void)
			{
				gl_FragColor	= vec4(1.0, 0.0, 0.0, 1.0);
				
				#ifdef DIFFUSE_MAP
					vec4 diffuse = texture2D(material.diffuseMap, vertexUV);
				#else
					vec4 diffuse = material.diffuseColor;
				#endif;

				light.direction = normalize(-light.direction);
				worldNormal = normalize(worldNormal);
				
				vec3 wsEyeVector	= normalize(cameraPosition - worldPosition);
				
				// by default, everything is in world space
				vec3 fNormal		= worldNormal;
				vec3 fLightVector	= light.direction;
				vec3 fEyeVector		= wsEyeVector;
				
				#ifdef NORMAL_MAP
					// compute the world space to tangent space matrix using the model's normal and tangent
					worldTangent				= normalize(worldTangent);
					vec3 worldBitangent			= cross(worldNormal, worldTangent);
					mat3 worldToTangentMatrix	= transpose(mat3(
						worldTangent,
						worldBitangent,
						worldNormal
					));

					// map all world-space vectors to tangent-space
					fNormal			= normalize(2.0 * texture2D(material.normalMap, vertexUV).xyz - 1.0);
					fLightVector	= normalize(worldToTangentMatrix * light.direction);
					fEyeVector		= normalize(worldToTangentMatrix * wsEyeVector);
				#endif // NORMAL_MAP
				
				// ambient + diffuse lighting
				diffuse.rgb *= light.ambient + phong_diffuseReflection(
					fNormal, 
					fLightVector, 
					light.diffuse
				);
				
				// specular lighting
				#if defined(SPECULAR) || defined(SPECULAR_MAP)
					#ifdef SPECULAR_MAP
						vec3 specular	= texture2D(material.specularMap, vertexUV).rgb;
					#else // SPECULAR_MAP
						vec3 specular	= material.specular;
					#endif // SPECULAR_MAP
				
					diffuse.rgb += phong_specularReflection(
						fNormal,
						fLightVector,
						fEyeVector,
						specular * light.specular,
						material.shininess
					);					
				#endif // SPECULAR || SPECULAR_MAP
								
				gl_FragColor = saturate(diffuse);
			}
		"
	}]
}
